#' Generate predictions from a `rankprob` object
#'
#' `predict()` computes predictions from a `rankprob` object, which is a multinomial regression object processed by [convert_rankprob()].
#'
#' @param object a `rankprob` object; the output of a call to [convert_rankprob()].
#' @param newdata the new data used to compute predictions. If `NULL`, the original data used to fit the model will be used.
#' @param type the type of prediction desired. If `"rank_probs"`, the probability of the ranking identified in `rankings` will be computed. Otherwise passed the `predict()` method for the original model fit. Note `"rank_probs"` cannot be abbreviated, but as the default, it also doesn't need to be specified.
#' @param rankings when `type = "rank_probs"`, a list of character vectors that identify the rankings for which predicted probabilities are to be computed. Can also be a single character vector for a single ranking. If `NULL`, will compute the ranking of the outcome levels in their original order. Each ranking must contain all levels of the original outcome.
#' @param \dots further arguments pass to `predict()` when `type` is not `"rank_probs"`.
#'
#' @details
#' `predict()` produces the predicted probability of each supplied ranking when `type = "rank_probs"`. For each ranking \eqn{r = \{y_1, y_2, ..., y_p\}}, the predicted probability of the ranking is equal to
#' \deqn{
#' p^r = \prod_{i = 1}^p {\frac{p_i}{\sum_{j = i} ^ p {p_j}}}
#' }
#' where \eqn{p_i = P(Y = y_i|X)}.
#'
#' @returns
#' A matrix with a row for each unit and a column for each ranking, with each cell equal to the predicted probability of that ranking being chosen for that unit.
#'
#' @seealso [convert_rankprob()]
#'
#' @note
#' When using `marginaleffects` functions, `type = "rank_probs"` must be specified for the functions to work correctly. You may see a warning beginning with something like "These arguments are not known to be supported for models of class `rankprob`: rankings." This can be ignored.
#'
#' @examplesIf requireNamespace("nnet", quietly = TRUE)
#'
#' data <- data.frame(x1 = rnorm(500),
#'                    x2 = rnorm(500),
#'                    x3 = rnorm(500),
#'                    y = sample(LETTERS[1:4], 500, TRUE))
#'
#' fit <- nnet::multinom(y ~ x1 + x2 + x3, data = data, Hess = TRUE)
#'
#' fit <- convert_rankprob(fit)
#'
#' p <- predict(fit, rankings = list(c("A", "B", "C", "D"),
#'                                   c("A", "C", "B", "D"),
#'                                   c("B", "A", "D", "C")))
#'
#' head(p)

#' @exportS3Method stats::predict rankprob
predict.rankprob <- function(object, newdata = NULL, type = "rank_probs", rankings = NULL, ...) {
  chk::chk_string(type)

  if (type != "rank_probs") {
    return(NextMethod("predict"))
  }

  prob_type <- attr(object, "rank_probs_prob_type")

  if (is.null(prob_type)) {
    chk::err("`object` needs an attribute called `\"rank_probs_prob_type\"` identifying the type of prediction used to compute class probabilities")
  }

  args <- list(object = object, type = prob_type, ...)

  if (!is.null(newdata)) {
    args[["newdata"]] <- newdata
  }

  p <- do.call("predict", args)

  if (!is.numeric(p)) {
    chk::err(sprintf("the predictions generated by calling `predict(., type = \"%s\")` are not probabilities",
                     prob_type))
  }

  if (!is.matrix(p)) {
    p <- matrix(p, ncol = ncol(stats::fitted(object)),
                dimnames = list(rownames(newdata), colnames(stats::fitted(object))))
  }

  k <- ncol(p)

  if (is.null(rankings)) {
    rankings <- list(colnames(p))
  }
  else if (!is.list(rankings)) {
    rankings <- list(rankings)
  }

  for (i in seq_along(rankings)) {

    rankings[[i]] <- as.character(rankings[[i]])

    if (length(rankings[[i]]) != k || !all(rankings[[i]] %in% colnames(p))  || !all(colnames(p) %in% rankings[[i]])) {
      chk::err("`rankings` must have a value for each level of the outcome")
    }
  }

  out <- do.call("cbind", lapply(rankings, function(o) {
    pred <- p[,o[1]]

    for (i in 2:k) {
      pred <- pred * p[,o[i]] / rowSums(p[,o[i:k], drop = FALSE])
    }

    pred
  }))

  colnames(out) <- unlist(lapply(rankings, paste, collapse = " > "))
  rownames(out) <- rownames(p)

  out
}
